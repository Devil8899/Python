#_author: liuz
#date: 2017/12/22

import os
'''5种IO
阻塞 I/O（blocking IO）
非阻塞 I/O（nonblocking IO）
I/O 多路复用（ IO multiplexing）
信号驱动 I/O（ signal driven IO）
异步 I/O（asynchronous IO）
'''
#阻塞IO 比如文件读取 发送网络数据等  执行时当前线程被挂起 后面代码无法执行 只有
'''
因为一个IO操作就阻塞了当前线程，导致其他代码无法执行，所以我们必须使用多线程或者多进程来并发执行代码，
为多个用户服务。
每个用户都会分配一个线程，如果遇到IO导致线程被挂起，其他用户的线程不受影响。
'''

'''
阻塞IO和非阻塞IO的区别：
调用阻塞会一直阻塞住对应的进程直到操作完成
非阻塞 IO在kernel还准备数据的情况下会立刻返回。
同步IO和异步IO的区别：
同步 IO做”IO 操作”的时候会将进程阻塞，阻塞IO、非阻塞IO、IO多路复用都是同步IO
异步则不一样，当进程发起IO 操作之后，就直接返回再也不理睬了，直到kernel发送一个信号，告诉进程说IO完成。在这整个过程中，进程完全没有被阻塞。
'''


'''
我们已经知道，CPU的速度远远快于磁盘、网络等IO。
在一个线程中，CPU执行代码的速度极快，然而，一旦遇到IO操作，如读写文件、发送网络数据时，
就需要等待IO操作完成，才能继续进行下一步操作。这种情况称为同步IO。

在IO操作的过程中，当前线程被挂起，而其他需要CPU执行的代码就无法被当前线程执行了。
因为一个IO操作就阻塞了当前线程，导致其他代码无法执行，
所以我们必须使用多线程或者多进程来并发执行代码，为多个用户服务。
每个用户都会分配一个线程，如果遇到IO导致线程被挂起，其他用户的线程不受影响。

多线程和多进程的模型虽然解决了并发问题，但是系统不能无上限地增加线程。
由于系统切换线程的开销也很大，所以，一旦线程数量过多，CPU的时间就花在线程切换上了，
真正运行代码的时间就少了，结果导致性能严重下降。

由于我们要解决的问题是CPU高速执行能力和IO设备的龟速严重不匹配，
多线程和多进程只是解决这一问题的一种方法。

另一种解决IO问题的方法是异步IO。当代码需要执行一个耗时的IO操作时，
它只发出IO指令，并不等待IO结果，然后就去执行其他代码了。
一段时间后，当IO返回结果时，再通知CPU进行处理。
'''
